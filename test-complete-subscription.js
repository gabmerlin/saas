// Test complet avec agence valide et agence expir√©e
require('dotenv').config({ path: './.env.local' });
const { createClient } = require('@supabase/supabase-js');

const BASE_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Client Supabase avec service role
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

async function createTestData() {
  console.log('üèóÔ∏è  Cr√©ation des donn√©es de test...');
  
  try {
    // 1. Cr√©er un plan d'abonnement de test
    const { data: plan, error: planError } = await supabase
      .from('subscription_plan')
      .upsert({
        id: 'test-plan-123',
        name: 'Test Plan',
        description: 'Plan de test pour les abonnements',
        price_usd: 29.99,
        billing_cycle: 'monthly',
        features: ['feature1', 'feature2'],
        is_active: true
      })
      .select()
      .single();

    if (planError) {
      console.log('‚ö†Ô∏è  Plan existant ou erreur:', planError.message);
    } else {
      console.log('‚úÖ Plan cr√©√©:', plan.name);
    }

    // 2. Cr√©er une agence valide (r√©cente)
    const validAgency = {
      id: 'valid-agency-123',
      name: 'Agence Valide Test',
      subdomain: 'agence-valide',
      locale: 'fr',
      created_at: new Date().toISOString()
    };

    const { data: validTenant, error: validTenantError } = await supabase
      .from('tenants')
      .upsert(validAgency)
      .select()
      .single();

    if (validTenantError) {
      console.log('‚ö†Ô∏è  Agence valide existante ou erreur:', validTenantError.message);
    } else {
      console.log('‚úÖ Agence valide cr√©√©e:', validTenant.name);
    }

    // 3. Cr√©er une agence expir√©e (ancienne)
    const expiredAgency = {
      id: 'expired-agency-456',
      name: 'Agence Expir√©e Test',
      subdomain: 'agence-expiree',
      locale: 'fr',
      created_at: new Date(Date.now() - 50 * 24 * 60 * 60 * 1000).toISOString() // 50 jours
    };

    const { data: expiredTenant, error: expiredTenantError } = await supabase
      .from('tenants')
      .upsert(expiredAgency)
      .select()
      .single();

    if (expiredTenantError) {
      console.log('‚ö†Ô∏è  Agence expir√©e existante ou erreur:', expiredTenantError.message);
    } else {
      console.log('‚úÖ Agence expir√©e cr√©√©e:', expiredTenant.name);
    }

    // 4. Cr√©er un abonnement actif pour l'agence valide
    const validSubscription = {
      id: 'valid-sub-123',
      tenant_id: validAgency.id,
      plan_id: 'test-plan-123',
      status: 'active',
      current_period_start: new Date().toISOString(),
      current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 jours
      price_locked_usd: 29.99
    };

    const { data: validSub, error: validSubError } = await supabase
      .from('subscription')
      .upsert(validSubscription)
      .select()
      .single();

    if (validSubError) {
      console.log('‚ö†Ô∏è  Abonnement valide existant ou erreur:', validSubError.message);
    } else {
      console.log('‚úÖ Abonnement valide cr√©√©:', validSub.status);
    }

    // 5. Cr√©er un abonnement expir√© pour l'agence expir√©e
    const expiredSubscription = {
      id: 'expired-sub-456',
      tenant_id: expiredAgency.id,
      plan_id: 'test-plan-123',
      status: 'active', // On va le laisser actif pour tester le cron
      current_period_start: new Date(Date.now() - 40 * 24 * 60 * 60 * 1000).toISOString(), // 40 jours
      current_period_end: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(), // 10 jours
      price_locked_usd: 29.99
    };

    const { data: expiredSub, error: expiredSubError } = await supabase
      .from('subscription')
      .upsert(expiredSubscription)
      .select()
      .single();

    if (expiredSubError) {
      console.log('‚ö†Ô∏è  Abonnement expir√© existant ou erreur:', expiredSubError.message);
    } else {
      console.log('‚úÖ Abonnement expir√© cr√©√©:', expiredSub.status);
    }

    // 6. Cr√©er des transactions
    const validTransaction = {
      id: 'valid-transaction-123',
      tenant_id: validAgency.id,
      plan_id: 'test-plan-123',
      btcpay_invoice_id: 'valid-invoice-123',
      amount_usd: 29.99,
      currency: 'USD',
      status: 'paid',
      payment_method: 'BTC',
      created_at: new Date().toISOString(),
      paid_at: new Date().toISOString()
    };

    const { data: validTrans, error: validTransError } = await supabase
      .from('transaction')
      .upsert(validTransaction)
      .select()
      .single();

    if (validTransError) {
      console.log('‚ö†Ô∏è  Transaction valide existante ou erreur:', validTransError.message);
    } else {
      console.log('‚úÖ Transaction valide cr√©√©e:', validTrans.status);
    }

    console.log('\nüéØ Donn√©es de test cr√©√©es avec succ√®s !');
    return {
      validAgency,
      expiredAgency,
      validSubscription,
      expiredSubscription
    };

  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation des donn√©es:', error);
    throw error;
  }
}

async function testEndpoints() {
  console.log('\nüß™ Test des endpoints...');
  
  const cronSecret = process.env.CRON_SECRET || 'test-secret';
  const cronHeaders = { 'Authorization': `Bearer ${cronSecret}` };

  // Test 1: V√©rification des abonnements expir√©s
  console.log('\n1Ô∏è‚É£ Test: V√©rification des abonnements expir√©s');
  try {
    const response = await fetch(`${BASE_URL}/api/cron/check-expired-subscriptions`, {
      method: 'GET',
      headers: cronHeaders
    });
    const data = await response.json();
    console.log(`   Status: ${response.status}`);
    console.log(`   Response:`, JSON.stringify(data, null, 2));
  } catch (error) {
    console.log(`   ‚ùå Erreur: ${error.message}`);
  }

  // Test 2: Nettoyage des agences non pay√©es
  console.log('\n2Ô∏è‚É£ Test: Nettoyage des agences non pay√©es');
  try {
    const response = await fetch(`${BASE_URL}/api/cron/cleanup-unpaid-agencies`, {
      method: 'GET',
      headers: cronHeaders
    });
    const data = await response.json();
    console.log(`   Status: ${response.status}`);
    console.log(`   Response:`, JSON.stringify(data, null, 2));
  } catch (error) {
    console.log(`   ‚ùå Erreur: ${error.message}`);
  }

  // Test 3: Statut de l'agence valide
  console.log('\n3Ô∏è‚É£ Test: Statut de l\'agence valide');
  try {
    const response = await fetch(`${BASE_URL}/api/agency/status?subdomain=agence-valide`, {
      method: 'GET'
    });
    const data = await response.json();
    console.log(`   Status: ${response.status}`);
    console.log(`   Response:`, JSON.stringify(data, null, 2));
  } catch (error) {
    console.log(`   ‚ùå Erreur: ${error.message}`);
  }

  // Test 4: Statut de l'agence expir√©e
  console.log('\n4Ô∏è‚É£ Test: Statut de l\'agence expir√©e');
  try {
    const response = await fetch(`${BASE_URL}/api/agency/status?subdomain=agence-expiree`, {
      method: 'GET'
    });
    const data = await response.json();
    console.log(`   Status: ${response.status}`);
    console.log(`   Response:`, JSON.stringify(data, null, 2));
  } catch (error) {
    console.log(`   ‚ùå Erreur: ${error.message}`);
  }
}

async function checkDatabaseState() {
  console.log('\nüìä √âtat de la base de donn√©es...');
  
  try {
    // V√©rifier les abonnements
    const { data: subscriptions, error: subError } = await supabase
      .from('subscription')
      .select('*')
      .order('created_at', { ascending: false });

    if (subError) {
      console.log('‚ùå Erreur r√©cup√©ration abonnements:', subError.message);
    } else {
      console.log('\nüìã Abonnements:');
      subscriptions.forEach(sub => {
        console.log(`   - ${sub.id}: ${sub.status} (${sub.tenant_id})`);
        console.log(`     P√©riode: ${sub.current_period_start} ‚Üí ${sub.current_period_end}`);
      });
    }

    // V√©rifier les agences
    const { data: tenants, error: tenantError } = await supabase
      .from('tenants')
      .select('*')
      .order('created_at', { ascending: false });

    if (tenantError) {
      console.log('‚ùå Erreur r√©cup√©ration agences:', tenantError.message);
    } else {
      console.log('\nüè¢ Agences:');
      tenants.forEach(tenant => {
        const daysSinceCreation = Math.floor((Date.now() - new Date(tenant.created_at).getTime()) / (1000 * 60 * 60 * 24));
        console.log(`   - ${tenant.name} (${tenant.subdomain}): ${daysSinceCreation} jours`);
      });
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification de la base:', error);
  }
}

async function cleanupTestData() {
  console.log('\nüßπ Nettoyage des donn√©es de test...');
  
  try {
    // Supprimer les donn√©es de test
    await supabase.from('transaction').delete().in('id', ['valid-transaction-123']);
    await supabase.from('subscription').delete().in('id', ['valid-sub-123', 'expired-sub-456']);
    await supabase.from('tenants').delete().in('id', ['valid-agency-123', 'expired-agency-456']);
    await supabase.from('subscription_plan').delete().eq('id', 'test-plan-123');
    
    console.log('‚úÖ Donn√©es de test supprim√©es');
  } catch (error) {
    console.log('‚ö†Ô∏è  Erreur lors du nettoyage:', error.message);
  }
}

async function runCompleteTest() {
  console.log('üöÄ Test Complet du Syst√®me d\'Abonnement');
  console.log('='.repeat(60));
  
  try {
    // 1. Cr√©er les donn√©es de test
    await createTestData();
    
    // 2. V√©rifier l'√©tat initial
    await checkDatabaseState();
    
    // 3. Tester les endpoints
    await testEndpoints();
    
    // 4. V√©rifier l'√©tat final
    console.log('\nüìä √âtat final apr√®s les tests...');
    await checkDatabaseState();
    
    // 5. Nettoyage
    await cleanupTestData();
    
    console.log('\n' + '='.repeat(60));
    console.log('‚ú® Test complet termin√© !');
    
  } catch (error) {
    console.error('üí• Erreur lors du test:', error);
  }
}

// Ex√©cuter le test
runCompleteTest().catch(console.error);
